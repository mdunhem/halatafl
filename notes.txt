0     F-.-F    
      |\|/|    
1     .-.-.    
      |/|\|    
2 .-.-.-.-.-.-.
  |\|/|\|/|\|/|
3 S-S-S-S-S-S-S
  |/|\|/|\|/|\|
4 S-S-S-S-S-S-S
      |\|/|    
5     S-S-S    
      |/|\|    
6     S-S-S    
  0 1 2 3 4 5 6

if row is even and column is odd or if row is odd and column is even, can only make left-right or up-down move:
moves: {
    up: coordinate.x, coordinate.y--,
    down: coordinate.x, coordinate.y++,
    left: coordinate.x--, coordinate.y,
    right: coordinate.x++, coordinate.y
}

else:
moves: {
    up: coordinate.x, coordinate.y--,
    down: coordinate.x, coordinate.y++,

    left: coordinate.x--, coordinate.y,
    right: coordinate.x++, coordinate.y,

    upLeft: coordinate.x--, coordinate.y--,
    upRight: coordinate.x++, coordinate.y--,
    downLeft: coordinate.x--, coordinate.y++,
    downRight: coordinate.x++, coordinate.y++
}

Fox fox {
    location = (0, 4)
    struct surroundingValues {
        char up = INVALID_SPACE
        char down = INVALID_SPACE
        char left = INVALID_SPACE
        char right = INVALID_SPACE
        char upLeft = INVALID_SPACE
        char upRight = INVALID_SPACE
        char downLeft = INVALID_SPACE
        char downRight = INVALID_SPACE
    }
    void determineSurroundingValues(BoardLayout)
}

void determineSurroundingValues(BoardLayout) {
    fox.surroundingValues.up = boardLayout.getValueAt(Coordinate(location.x, location.y--));
    fox.surroundingValues.down = boardLayout.getValueAt(Coordinate(location.x, location.y++));
    fox.surroundingValues.left = boardLayout.getValueAt(Coordinate(location.x--, location.y));
    fox.surroundingValues.right = boardLayout.getValueAt(Coordinate(location.x++, location.y));
    fox.surroundingValues.upLeft = boardLayout.getValueAt(Coordinate(location.x--, location.y--));
    fox.surroundingValues.upRight = boardLayout.getValueAt(Coordinate(location.x++, location.y--));
    fox.surroundingValues.downLeft = boardLayout.getValueAt(Coordinate(location.x--, location.y++));
    fox.surroundingValues.downRight = boardLayout.getValueAt(Coordinate(location.x++, location.y++));
}

if (location.x % 2 == 0 && location.y % 2 != 0) {
    if fox.surroundingValues.up == 'S' || ... {

    }
}

struct Cell {
    const int x;
    const int y;
    const char columnCharacter;
    char value;
    Cell *up;
    Cell *down;
}

Jump::
    Cell startCell;
    Cell endCell;

Move::
    vector<Jump> jumps;

FoxPlayer::
    get locations of each fox
    get surrounding values (std::map<string, Cell> ?)

BoardLayout::
    vector<vector<Cell>> layout;


Fox searches for adjoining cells and puts them in a vector. Then iterates through each searching for a sheep. If one found, check for open space on other side of sheep. If open add move to potential move vector. Then act as if move has been made and repeat process. If open space on other side is not available, add jump to potential threats vector. Then search for other sheep and repeat process. Once all sheep have been found and potential moves made, if sheep can be eaten, return the one with most amount of jumps. If no sheep found, pick an open space adjoining to move to at random and return it. If no moves are possible, i.e. Sheep have trapped the fox, then return a move with start and end cells that are same location that the fox is at already.



foxes = boardLayout.getFoxCells();
for each fox in foxes {
    fox.determinePossibleJump();
    map<Direction, Cell>secondRowSurroundingValues = fox.getSurroundingValuesWithRadius(2);
    for each secondRowSurroundingValues {
        if surroundingValue.value = sheep {
            make new jump going to position next to sheep
            then add to potentialThreats
        }
    }
}

compare foxes moves and which one is greater. then pick that one as our move.
otherwise, compare the potentialThreats. pick the one with the highest number.
if neither has one, pick a random fox.potentialMove

// Needs base case
function determinePossibleJump() {
    map<Direction, Cell>surroundingValues = fox.getSurroundingValuesWithRadius(1);
    for each surroundingValues {
        if surroundingValue.value = sheep {
            if can jump it {
                Jump jump(fox.cell, surroundingValue.second)
                fox.move.jumps.push_back(jump);
                fox.cell = surroundingValue.second;
                fox.boardLayout.makeJump(jump);
                // Recursive call
                fox.determinePossibleJump();
            }
        }
    }
}



